# I/O

- 현대 컴퓨터는 대부분 byte 단위로 데이터를 추고 받는다. 파일을 받을 수도 있고 네트워크나 콘솔로 입력을 받을 수도 있다.
- 각자의 방식을 추상화 한 클래스가 InputStream, OutputStream이다.

## BufferedInputStream / BufferedOutputStream

- 버퍼를 사용하면 I/O 시스템 콜을 적게 호출하면서 성능이 올라간다.
- 디스크나 파일 시스템에서 데이터를 읽고 쓰는 기본 단위가 4KB or 8KB이기 때문에 한 번에 크게 한다고 무작정 빠른 것은 아니다.

### 직접 버퍼를 다루는 것보다 느린 이유

- 동기화 코드가 걸려있다.
- write()를 1000만 번 한다면 lock도 1000만 번 잠겼다 풀린다.
- 싱글 스레드 상황에서는 동기화 락이 필요하지 않기 때문에 직접 버퍼를 사용할 때보다 성능이 떨어진다.
- 매우 큰 데이터를 다루고 성능 최적화가 필요하다면 직접 버퍼를 다루는 게 낫다.
    - 동기화가 없는 버퍼 기능은 없다.

## 기본 스트림, 보조 스트림

- FileOutputStream처럼 단독으로 사용 가능하면 기본 스트림이라고 한다.
- BufferedOutputStream처럼 단독으로 사용할 수 없고 보조적인 기능을 제공함면 보조 스트림이라고 한다.
    - 생성할 때도 기본 스트림을 대상으로 넣어줘야 가능하다.

## Reader / Writer

- 문자를 다루는 별도의 클래스
- byte 대신 문자를 받아서 처리한다.
    - 내부에서는 byte로 인코딩해서 처리한다.

## 객체 직렬화

- 메모리에 있는 객체 인스턴스를 바이트 스트림으로 변환해 파일에 저장하거나 네트워크로 전송할 수 있게 한다.
- Serializable 인터페이스를 구현해야 한다.
    - 아무 기능이 없는 마커 인터페이스

### 한계

- 버전 관리의 어려움
    - 클래스 구조가 변경되면 이전에 직렬화된 객체와의 호환성 문제가 발행한다.
    - serialVersionUID 관리가 복잡하다.
- 플랫폼 종속성
    - 자바 직렬화는 자바 플랫폼에 종속적이어서 다른 언어나 시스템과 상호 운용성이 떨어진다.
- 성능 이슈
    - 직렬화, 역직렬화 과정이 상대적으로 느리고 리소스를 많이 사용한다.
- 유연성 부족
    - 직렬화된 형식을 커스터마이즈 하기 어렵다.
- 크기 효율성
    - 상대적으로 크기가 크다.

### 대안

- XML
    - 초창기에 쓰이던 기술
    - 복잡하고 무겁다.
- JSON
    - 가볍고 간결하다.
    - 사실상 웹 환경의 표준
- Protobuf, Avro
    - 아주 작은 용량으로 더 빠른 속도가 필요할 때 사용한다.
    - 호환성은 떨어지지만 byte 기반에 용량과 성능 최적화가 되어있어 매우 빠르다.
    - 다만 byte 기반이므로 JSON처럼 사람이 읽기는 어렵다.
